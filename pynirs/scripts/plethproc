#!/usr/bin/env python
#
# $Author: frederic $
# $Date: 2016/09/20 20:47:15 $
#       $Id: plethproc.py,v 1.13 2016/09/20 20:47:15 frederic Exp $
#

from __future__ import print_function

import bisect
import getopt
import platform
import sys

import matplotlib
import numpy as np
import pandas as pd
import pylab as P

import pynirs.cbv_funcs as cbvf
import pynirs.spo2funcs as spo2

import argparse

DEFAULT_SAMPLERATE = 33.0
DEFAULT_SDSPACE = 1.0
DEFAULT_VISLAMBDA = 660
DEFAULT_IRLAMBDA = 920


def _get_parser():
    """
    Argument parser for plethproc
    """
    parser = argparse.ArgumentParser(
        prog="plethproc",
        description=("Process raw NIRS timecourses into hemodynamic measures"),
        usage="%(prog)s inputfile outputfile [options]",
    )

    # Required arguments
    parser.add_argument(
        "inputfile", type=str, help="The name of the medwatch recording."
    )
    parser.add_argument(
        "outputfile", type=str, help="The root name of the output files."
    )

    # add optional arguments
    parser.add_argument(
        "--samplerate",
        action="store",
        type=float,
        metavar="RATE",
        help=(f"Sample rate in Hz.  Default is {DEFAULT_SAMPLERATE}."),
        default=DEFAULT_SAMPLERATE,
    )
    parser.add_argument(
        "--vislambda",
        action="store",
        type=int,
        metavar="WAVELENGTH",
        help=(f"Visible wavelength, in nanometers.  Default is {DEFAULT_VISLAMBDA}."),
        default=DEFAULT_VISLAMBDA,
    )
    parser.add_argument(
        "--irlambda",
        action="store",
        type=int,
        metavar="WAVELENGTH",
        help=(f"IR wavelength, in nanometers.  Default is {DEFAULT_IRLAMBDA}."),
        default=DEFAULT_IRLAMBDA,
    )
    parser.add_argument(
        "--sdspace",
        action="store",
        type=float,
        metavar="DISTANCE",
        help=("Source-detector spacing, in centimeters. Default is {DEFAULT_SDSPACE}."),
        default=DEFAULT_SDSPACE,
    )
    return parser


def rms(x):
    return np.sqrt(x.dot(x) / x.size)


def extractnumber(s):
    try:
        return np.nan_to_num(float(s))
    except ValueError:
        return 0.0


##########################################################################################
#
# control flow starts here
#
##########################################################################################
##########################################################################################

# configurable parameters
useFIR = False
usebutterworthfilter = False
cardplot = True
lfoplot = True
raw_plot = True
numlines = 4
nsegs = 1
outnames = None
vislambda = 660
irlambda = 920
sdspace = 1.0

# set default variable values
peakfilter = False
dodisplay = True
dolegend = True
outsamplerate = 30.0
doresample = True
dontcombine = False
debug = False
directspec = False
fileiscsv = False
headernametype = "old"
writeindividual = False
starttime = 0.0
theheartrate = 0.0
despike = False
waveletdespike = False
waveletp = 0.05
doMARA = False
pMARA = 0.05
filtorder = 3
thepreprefilter = cbvf.noncausalfilter()
thepreprefilter.setbutter(usebutterworthfilter, filtorder)


# main event loop
def usage():
    print(
        "usage: plethproc inputfilename -o outputfilename [-s starttime] [-e endtime] [-S outputrate]"
    )
    print(
        "    [-d] [-w] [-p PVAL] [-W NSEGS] [-M] [-m MARAPVAL] [-D] [-n NAMES] [-l LINES]"
    )
    print("    [-F LOWERFREQ,UPPERFREQ[,LOWERSTOP,UPPERSTOP]] [-V] [-L] [-R] [-C]")
    print("    [-f LOWERFREQ,UPPERFREQ[,LOWERSTOP,UPPERSTOP]]")
    print("    [-P] [-i] [-N] [-x]")
    print("")
    print("required arguments:")
    print(
        "     inputfilename  - a plethpulse output file generated by a McLean oximeter"
    )
    print(
        "     -o outputfilename - the processed output file (HbO, HbR, tHb for raw, lfo, and cardiac bands, markers, and derived waveforms)"
    )
    print("")
    print("optional arguments:")
    print("     -s starttime   - time offset in seconds to use as the starting point")
    print(
        "     -e endtime     - time offset in seconds to use as the end point (negative times are relative to the end)"
    )
    print(
        "     -S outputrate  - sample rate in Hz to output the data (default is 30).  Set to -1 for no resampling"
    )
    print("     -d             - despike data")
    print("     -w             - use wavelet filter to despike data")
    print(
        "     -p PVAL      - set the p-value of the wavelet filter to PVAL (default is 0.05).  This enables wavelet filtering"
    )
    print(
        "	-W NSEGS       - rerun the wavelet filter NSEGS times with barrel shifts (improves denoising performance)"
    )  # NEW
    print("     -M             - do MARA spline interpolation")
    print(
        "     -m MARAPVAL    - set the MARA artifact threshhold p value (default is 0.05).  This enables MARA processing."
    )
    print(
        "     -F             - filter data and regressors from LOWERFREQ to UPPERFREQ."
    )
    print(
        "                      LOWERSTOP and UPPERSTOP can be specified, or will be calculated automatically"
    )
    print("     -V             - filter data and regressors to VLF band")
    print("     -L             - filter data and regressors to LFO band")
    print("     -R             - filter data and regressors to respiratory band")
    print("     -C             - filter data and regressors to cardiac band")
    print(
        "     -f             - filter data and regressors to REMOVE data from LOWERFREQ to UPPERFREQ."
    )
    print("     -D             - turn on debug mode.")
    print(
        "     -n             - use comma separated strings in NAMES as labels for the channels."
    )
    print("     -l LINES       - discard the first LINES lines of the header.")
    print(
        "     -X SAMPLERATE  - Assume input sample rate of SAMPLERATE - ignore 'Time' column"
    )
    print(
        "     -i             - save individual timecourse files (one waveform per text file - useful for debugging"
    )  # NEW
    print(
        "     -N             - no display option - just process files and leave without a display window"
    )  # NEW
    print("     -P             - enable smart cardiac peak postprocessing")  # NEW
    print(
        "     -x             - process optical channels separately (don't differentiate HbO and HbR)"
    )  # NEW

    return ()


def main():
    # get the command line parameters
    nargs = len(sys.argv)
    if nargs < 3:
        usage()
        sys.exit()

    # print version information
    print("$Id: plethproc.py,v 1.13 2016/09/20 20:47:15 frederic Exp $")

    # handle required args first
    # inputfilename = sys.argv[1]
    # outputfilename = sys.argv[2]

    # now scan for optional arguments
    # print("options:", sys.argv[2:])
    try:
        opts, args = getopt.gnu_getopt(
            sys.argv, "o:X:m:MxPiAHcDVLRCF:f:dwp:s:e:S:n:l:N", ["help"]
        )
    except getopt.GetoptError as err:
        # print help information and exit:
        print(str(err))  # will print something like "option -a not recognized"
        usage()
        sys.exit(2)

    inputfilenames = args[1:]
    print("inputfiles:", inputfilenames)
    print("opts:", opts)
    endtime = 0
    insamplerate = None
    for o, a in opts:
        if o == "-o":
            outputfilename = a
            print("output file set to ", outputfilename)
        elif o == "-s":
            starttime = float(a)
            print("starttime set to ", starttime)
        elif o == "-N":
            dodisplay = False
            print("disabling timecourse display")
        elif o == "-x":
            dontcombine = True
            print("processing optical channels independendtly")
        elif o == "-P":
            peakfilter = True
            print("enabling smart filtering of cardiac peaks")
        elif o == "-X":
            insamplerate = float(a)
            print("setting input sample rate to", insamplerate)
        elif o == "-l":
            numlines = int(a)
            print("assuming ", numlines, " header lines")
        elif o == "-c":
            fileiscsv = True
            headernametype = "new"
            print("Treating input file as PLUX csv file")
        elif o == "-i":
            writeindividual = True
            print("saving each timecourse in its own file")
        elif o == "-D":
            debug = True
            print("debugging mode on")
        elif o == "-w":
            waveletdespike = True
            despike = True
            print("using wavelet filter to despike data")
        elif o == "-W":
            waveletdespike = True
            despike = True
            nsegs = int(a)
            print("rerun wavelet filter", nsegs, "times with barrel shifts")
        elif o == "-M":
            doMARA = True
            print("will perform MARA baseline correction")
        elif o == "-m":
            doMARA = True
            pMARA = float(a)
            print(
                "doing MARA baseline correction with p-value of ",
                pMARA,
                "to remove motion artifacts",
            )
        elif o == "-p":
            waveletdespike = True
            despike = True
            waveletp = float(a)
            print("using wavelet filter with p-value of ", waveletp, "to despike data")
        elif o == "-d":
            despike = True
            print("despiking data")
        elif o == "-e":
            endtime = float(a)
            print("endtime set to ", endtime)
        elif o == "-S":
            outsamplerate = float(a)
            if outsamplerate < 0.0:
                doresample = False
                print("no resampling will be done")
            else:
                print("outsamplerate set to ", outsamplerate)
        elif o == "-V":
            thepreprefilter.settype("vlf")
            print("prefiltering to vlf band")
        elif o == "-L":
            thepreprefilter.settype("lfo")
            print("prefiltering to lfo band")
        elif o == "-R":
            thepreprefilter.settype("resp")
            print("prefiltering to respiratory band")
        elif o == "-C":
            thepreprefilter.settype("cardiac")
            print("prefiltering to cardiac band")
        elif o == "-f":
            arbvec = a.split(",")
            if len(arbvec) != 2 and len(arbvec) != 4:
                usage()
                sys.exit()
            if len(arbvec) == 2:
                arb_lower = float(arbvec[0])
                arb_upper = float(arbvec[1])
                arb_lowerstop = 0.9 * float(arbvec[0])
                arb_upperstop = 1.1 * float(arbvec[1])
            if len(arbvec) == 4:
                arb_lower = float(arbvec[0])
                arb_upper = float(arbvec[1])
                arb_lowerstop = float(arbvec[2])
                arb_upperstop = float(arbvec[3])
            thepreprefilter.settype("arb_stop")
            thepreprefilter.setarb(arb_lowerstop, arb_lower, arb_upper, arb_upperstop)
            print(
                "prefiltering to remove signal from ",
                arb_lower,
                arb_upper,
                "(stops at ",
                arb_lowerstop,
                arb_upperstop,
                ")",
            )
        elif o == "-n":
            outnames = a.split(",")
            print("using alternative names for output channels")
        elif o == "-A":  # NEW
            vislambda = 660  # NEW
            irlambda = 950  # NEW
            sdspace = 0.283  # Might this need to be 0.283?         # NEW
            print("this is PLUX armband data")
        elif o == "-H":  # NEW
            vislambda = 660  # NEW
            irlambda = 850  # NEW
            sdspace = 2.0  # NEW
            print("this is PLUX headband data")
        elif o == "-F":
            arbvec = a.split(",")
            if len(arbvec) != 2 and len(arbvec) != 4:
                usage()
                sys.exit()
            if len(arbvec) == 2:
                arb_lower = float(arbvec[0])
                arb_upper = float(arbvec[1])
                arb_lowerstop = 0.9 * float(arbvec[0])
                arb_upperstop = 1.1 * float(arbvec[1])
            if len(arbvec) == 4:
                arb_lower = float(arbvec[0])
                arb_upper = float(arbvec[1])
                arb_lowerstop = float(arbvec[2])
                arb_upperstop = float(arbvec[3])
            thepreprefilter.settype("arb")
            thepreprefilter.setarb(arb_lowerstop, arb_lower, arb_upper, arb_upperstop)
            print(
                "prefiltering to ",
                arb_lower,
                arb_upper,
                "(stops at ",
                arb_lowerstop,
                arb_upperstop,
                ")",
            )
        elif o in ("-h", "--help"):
            usage()
            sys.exit()
        else:
            assert False, "unhandled option"

    outsamplestep = 1.0 / outsamplerate

    # read data and initialize this and that
    print("reading in data")
    for inputfilename in inputfilenames:
        if not fileiscsv:
            thedata = pd.read_csv(
                inputfilename,
                header=numlines,
                skipfooter=3,
                engine="python",
                delim_whitespace=True,
            )
            if debug:
                print(thedata)
            if insamplerate is None:
                rawtimeaxis = thedata["Time"].values - thedata["Time"].values[0]
            else:
                arraylen = len(thedata.index)
                rawtimeaxis = np.linspace(
                    0.0, arraylen / insamplerate, num=arraylen, endpoint=False
                )
                headernametype = "new"
        else:
            thedata = pd.read_csv(inputfilename, header=0)
            if debug:
                print(thedata)
            rawtimeaxis = thedata["timestamp"].values - thedata["timestamp"].values[0]

    if outsamplerate < 0.0:
        outsamplerate = insamplerate

    print(
        "input sample rate is approximately ", 1.0 / (rawtimeaxis[1] - rawtimeaxis[0])
    )
    if starttime == 0:
        starttime = rawtimeaxis[0]
    if endtime == 0:
        endtime = rawtimeaxis[-1]
    if endtime > rawtimeaxis[-1]:
        endtime = rawtimeaxis[-1]
        print("endtime too large - setting to ", endtime)
    print("using starttime=", starttime, ", endtime=", endtime)
    if not directspec:
        startpoint = bisect.bisect_left(rawtimeaxis, starttime)
        if endtime < 0:
            endpoint = bisect.bisect_left(rawtimeaxis, rawtimeaxis[-1] + endtime)
            endtime = rawtimeaxis[endpoint]
        else:
            endpoint = bisect.bisect_left(rawtimeaxis, endtime)
    print("using startpoint=", startpoint, ", endpoint=", endpoint)
    intimeaxis = rawtimeaxis[startpoint:endpoint]
    insamplerate = (endpoint - startpoint) / (intimeaxis[-1] - intimeaxis[0])
    print("approximate input samplerate:", insamplerate)
    chanlist = ["CH1", "CH2", "CH3", "CH4", "CH5", "CH6", "CH7"]
    if outnames is None:
        outnames = chanlist
    else:
        for idx, value in enumerate(chanlist):
            if len(outnames) - 1 >= idx:
                if outnames[idx] is None:
                    outnames.append(value)
            else:
                outnames.append(value)
    print("outnames is ", outnames)
    inirdata = []
    invisdata = []
    thechans = []
    # cardcenter = (60.0 / 72.0) * insamplerate
    cardcenter = None
    if not fileiscsv:
        for thischan in chanlist:
            try:
                inirdata.append(thedata[thischan + "-IR"].values[startpoint:endpoint])
            except KeyError:
                pass
            else:
                invisdata.append(thedata[thischan + "-VS"].values[startpoint:endpoint])
                thechans.append(thischan)
                print("found and added data from ", thischan)
                if despike:
                    print("despiking")
                    if waveletdespike:
                        inirdata[-1] = spo2.multidespike(
                            inirdata[-1],
                            nsegs=nsegs,
                            pvalue=waveletp,
                            avoid=cardcenter,
                            verbose=debug,
                            debug=debug,
                        )
                        invisdata[-1] = spo2.multidespike(
                            invisdata[-1],
                            nsegs=nsegs,
                            pvalue=waveletp,
                            avoid=cardcenter,
                            verbose=debug,
                            debug=debug,
                        )
                    else:
                        inirdata[-1] = spo2.despike(inirdata[-1])
                        invisdata[-1] = spo2.despike(invisdata[-1])
    else:
        inirdata.append(thedata["IR_Transmission"].values[startpoint:endpoint])
        invisdata.append(thedata["Visible_Transmission"].values[startpoint:endpoint])
        thechans.append(chanlist[0])
        if despike:
            print("despiking")
            if waveletdespike:
                inirdata[-1] = spo2.multidespike(
                    inirdata[-1],
                    nsegs=nsegs,
                    pvalue=waveletp,
                    avoid=cardcenter,
                    verbose=debug,
                    debug=debug,
                )
                invisdata[-1] = spo2.multidespike(
                    invisdata[-1],
                    nsegs=nsegs,
                    pvalue=waveletp,
                    avoid=cardcenter,
                    verbose=debug,
                    debug=debug,
                )
            else:
                inirdata[-1] = spo2.despike(inirdata[-1])
                invisdata[-1] = spo2.despike(invisdata[-1])

    # extract the markers
    print("detecting markers")
    if not fileiscsv:
        try:
            tempbuttonmarkers = thedata["B"].values[startpoint:endpoint]
        except:
            tempbuttonmarkers = intimeaxis * 0
        try:
            tempcalibmarkers = thedata["C"].values[startpoint:endpoint]
        except:
            tempcalibmarkers = intimeaxis * 0
    else:
        tempbuttonmarkers = thedata["Marker"].values[startpoint:endpoint]
        tempcalibmarkers = thedata["Marker"].values[startpoint:endpoint]

    # compensate for pandas' inability to handle empty columns intelligently
    inbuttonmarkers = np.zeros(len(tempbuttonmarkers))
    for i in range(0, len(tempbuttonmarkers)):
        inbuttonmarkers[i] = extractnumber(tempbuttonmarkers[i])

    incalibmarkers = np.zeros(len(tempcalibmarkers))
    for i in range(0, len(tempcalibmarkers)):
        incalibmarkers[i] = extractnumber(tempcalibmarkers[i])

    try:
        tempaccx = thedata["ACC_X"].values[startpoint:endpoint]
        tempaccy = thedata["ACC_Y"].values[startpoint:endpoint]
        tempaccz = thedata["ACC_Z"].values[startpoint:endpoint]
        inaccx = np.zeros(len(tempaccx))
        inaccy = np.zeros(len(tempaccy))
        inaccz = np.zeros(len(tempaccz))
        for i in range(0, len(tempaccx)):
            inaccx[i] = extractnumber(tempaccx[i])
            inaccy[i] = extractnumber(tempaccy[i])
            inaccz[i] = extractnumber(tempaccz[i])
        accexists = True
    except KeyError:
        accexists = False

    try:
        tempsyncmarkers = thedata["S"].values[startpoint:endpoint]
        insyncmarkers = np.zeros(len(tempsyncmarkers))
        for i in range(0, len(tempsyncmarkers)):
            insyncmarkers[i] = extractnumber(tempsyncmarkers[i])
        syncsexist = True
    except KeyError:
        syncsexist = False

    try:
        tempexternalmarkers = thedata["E"].values[startpoint:endpoint]
        inexternalmarkers = np.zeros(len(tempexternalmarkers))
        for i in range(0, len(tempexternalmarkers)):
            inexternalmarkers[i] = extractnumber(tempexternalmarkers[i])
        externalsexist = True
    except KeyError:
        externalsexist = False

    try:
        temptogglemarkers = thedata["T"].values[startpoint:endpoint]
        intogglemarkers = np.zeros(len(temptogglemarkers))
        for i in range(0, len(temptogglemarkers)):
            intogglemarkers[i] = extractnumber(tempcalibmarkers[i])
        togglesexist = True
    except KeyError:
        togglesexist = False

    buttonmarkerlist = []
    calibmarkerlist = []
    togglemarkerlist = []
    externalmarkerlist = []
    syncmarkerlist = []

    if np.max(inbuttonmarkers) > 0:
        for i in range(0, len(inbuttonmarkers)):
            if int(inbuttonmarkers[i]) == 1:
                buttonmarkerlist.append(intimeaxis[i])
                print("button marker at ", intimeaxis[i], " seconds")

    if np.max(incalibmarkers) > 0:
        for i in range(0, len(incalibmarkers)):
            if int(incalibmarkers[i]) == 1:
                calibmarkerlist.append(intimeaxis[i])

    if syncsexist:
        if np.max(insyncmarkers) > 0:
            for i in range(0, len(insyncmarkers)):
                if int(insyncmarkers[i]) == 1:
                    syncmarkerlist.append(intimeaxis[i])

    if externalsexist:
        if np.max(inexternalmarkers) > 0:
            for i in range(0, len(inexternalmarkers)):
                if int(inexternalmarkers[i]) == 1:
                    externalmarkerlist.append(intimeaxis[i])

    if togglesexist:
        if int(intogglemarkers[0]) == 1:
            toggleishigh = True
        else:
            toggleishigh = False
        if np.max(intogglemarkers) > 0:
            for i in range(0, len(intogglemarkers)):
                if int(intogglemarkers[i]) == 1:
                    togglemarkerlist.append(intimeaxis[i])
                    if not toggleishigh:
                        print("toggle went high at ", intimeaxis[i], " seconds")
                        toggleishigh = True
                else:
                    if toggleishigh:
                        print("toggle went low at ", intimeaxis[i], " seconds")
                        toggleishigh = False

                        # epochs=spo2.parsetriggers(triggermarkerlist)
                        # if epochs:
                        # for i in range(0,len(epochs[:][0])):
                        # print("Epoch ",i+1," starts at ",epochs[i][0]," and ends at ",epochs[i][1],".  ",epochs[i][2]," triggers with spacing of ",epochs[i][3]*1000.0,"ms")

    print("input data lengths", len(intimeaxis), len(invisdata))
    outirdata = []
    outvisdata = []

    if doresample:
        print("resampling to ", outsamplerate)
        print(
            "starttime=",
            starttime,
            ", endtime=",
            endtime,
            ", outsamplestep=",
            outsamplestep,
        )
        # outtimeaxis = np.arange(starttime, endtime, outsamplestep)
        outtimeaxis = np.linspace(
            starttime,
            endtime,
            num=int((endtime - starttime) // outsamplestep),
            endpoint=False,
        )
        for channum in range(0, len(thechans)):
            outirdata.append(
                cbvf.doresample(
                    intimeaxis, inirdata[channum], outtimeaxis, method="univariate"
                )
            )
            outvisdata.append(
                cbvf.doresample(
                    intimeaxis, invisdata[channum], outtimeaxis, method="univariate"
                )
            )
        outhbmarkers = np.zeros((len(outvisdata[0])), dtype="int")
        outbuttonmarkers = np.zeros((len(outvisdata[0])), dtype="int")
        outtogglemarkers = np.zeros((len(outvisdata[0])), dtype="int")
        outcalibmarkers = np.zeros((len(outvisdata[0])), dtype="int")
        outexternalmarkers = np.zeros((len(outvisdata[0])), dtype="int")
        outsyncmarkers = np.zeros((len(outvisdata[0])), dtype="int")
        outaccx = np.zeros((len(outvisdata[0])), dtype="float")
        outaccy = np.zeros((len(outvisdata[0])), dtype="float")
        outaccz = np.zeros((len(outvisdata[0])), dtype="float")
        if accexists:
            outaccx = cbvf.doresample(
                intimeaxis, inaccx, outtimeaxis, method="univariate"
            )
            outaccy = cbvf.doresample(
                intimeaxis, inaccy, outtimeaxis, method="univariate"
            )
            outaccz = cbvf.doresample(
                intimeaxis, inaccz, outtimeaxis, method="univariate"
            )

        for i in range(0, len(togglemarkerlist)):
            if togglemarkerlist[i] >= starttime:
                outtogglemarkers[
                    int((togglemarkerlist[i] - starttime) / outsamplestep)
                ] = 1
        for i in range(0, len(buttonmarkerlist)):
            if buttonmarkerlist[i] >= starttime:
                outbuttonmarkers[
                    int((buttonmarkerlist[i] - starttime) / outsamplestep)
                ] = 1
        for i in range(0, len(calibmarkerlist)):
            if calibmarkerlist[i] >= starttime:
                outcalibmarkers[
                    int((calibmarkerlist[i] - starttime) / outsamplestep)
                ] = 1
        if syncsexist:
            for i in range(0, len(syncmarkerlist)):
                if syncmarkerlist[i] >= starttime:
                    outsyncmarkers[
                        int((syncmarkerlist[i] - starttime) / outsamplestep)
                    ] = 1
        if externalsexist:
            for i in range(0, len(externalmarkerlist)):
                if externalmarkerlist[i] >= starttime:
                    outexternalmarkers[
                        int((externalmarkerlist[i] - starttime) / outsamplestep)
                    ] = 1
    """
    else:
        for channum in range(0, len(thechans)):
            outirdata.append(inirdata[channum])
            outvisdata.append(invisdata[channum])
        outmarkers = inbuttonmarkers
        outtimeaxis = intimeaxis
        outhbmarkers = intimeaxis * 0
        outbuttonmarkers = inbuttonmarkers
        outcalibmarkers = incalibmarkers
        if syncsexist:
            outsyncmarkers = insyncmarkers
        if externalsexist:
            outexternalmarkers = inexternalmarkers
        if togglesexist:
            outtogglemarkers = intogglemarkers
        outcalibmarkers = incalibmarkers
    """
    print("output data lengths", len(outtimeaxis), len(outvisdata[0]))
    if debug:
        outvec = np.zeros((2, len(intimeaxis)), dtype="float")
        outvec[0, :] = intimeaxis
        outvec[1, :] = invisdata[0]
        cbvf.writenpvecs(outvec, "initialvis.txt")
        outvec = np.zeros((2, len(outtimeaxis)), dtype="float")
        outvec[0, :] = outtimeaxis
        outvec[1, :] = outvisdata[0]
        cbvf.writenpvecs(outvec, "resampledvis.txt")

    # calculate the spo2 using the ratio method
    ratiospo2 = []
    irnormfac = []
    visnormfac = []
    HbOrawdata = []
    HbRrawdata = []
    tHbrawdata = []
    for channum in range(0, len(thechans)):
        print("processing channel ", thechans[channum])
        print("calculating oxygenation")
        ratiospo2.append(
            spo2.optical2spo2(outirdata[channum], outvisdata[channum], outsamplerate)
        )

        print("normalizing")
        irnormfac.append(np.mean(outirdata[channum]))
        visnormfac.append(np.mean(outvisdata[channum]))

        print("converting to oxy-deoxy")
        if thepreprefilter.gettype() == "none":
            print("optical timecourses will not be prefiltered")
        else:
            print("optical timecourses will prefiltered to ", thepreprefilter.gettype())
            outirdata[channum] = thepreprefilter.apply(
                outsamplerate, outirdata[channum]
            )
            outvisdata[channum] = thepreprefilter.apply(
                outsamplerate, outvisdata[channum]
            )

        thisHbOraw, thisHbRraw, thistHbraw = spo2.nirstohb(
            outirdata[channum] / irnormfac[channum],
            outvisdata[channum] / visnormfac[channum],
            lambda1=vislambda,
            lambda2=irlambda,
            sdspace=sdspace,
            dontcombine=dontcombine,
        )
        if doMARA:
            print("doing MARA baseline correction")
            thisHbOraw = spo2.MARA(
                np.nan_to_num(thisHbOraw), outsamplerate, pvalue=pMARA
            )
            thisHbRraw = spo2.MARA(
                np.nan_to_num(thisHbRraw), outsamplerate, pvalue=pMARA
            )
            thistHbraw = spo2.MARA(
                np.nan_to_num(thistHbraw), outsamplerate, pvalue=pMARA
            )
        HbOrawdata.append(np.nan_to_num(thisHbOraw))
        HbRrawdata.append(np.nan_to_num(thisHbRraw))
        tHbrawdata.append(np.nan_to_num(thistHbraw))

    if useFIR:
        delaypoints = spo2.maxdelay()

    numoutpoints = len(outtimeaxis)

    HbOcarddata = []
    HbRcarddata = []
    tHbcarddata = []
    HbOrespdata = []
    HbRrespdata = []
    tHbrespdata = []
    HbOlfodata = []
    HbRlfodata = []
    tHblfodata = []
    tHblowpass = []
    HbOcardrms = []
    HbRcardrms = []
    tHbcardrms = []
    HbOcardsq = []
    HbRcardsq = []
    tHbcardsq = []
    peaks = []
    pdpeaks = []
    rrinterval = []
    instbpm = []
    avgbpm = []
    peakheight = []
    confidence = []
    peakwaveform = []
    fftbpm = []
    instspo2 = []
    cardmax = []
    cardmin = []

    docardproc = True
    for channum in range(0, len(thechans)):
        print("processing data for channel: ", outnames[channum])
        if useFIR:
            HbOcarddata.append(np.zeros(numoutpoints, dtype=float))
            HbOrespdata.append(np.zeros(numoutpoints, dtype=float))
            HbOlfodata.append(np.zeros(numoutpoints, dtype=float))
            HbOcardsq.append(np.zeros(numoutpoints, dtype=float))
            HbOcardrms.append(np.zeros(numoutpoints, dtype=float))
            HbRcarddata.append(np.zeros(numoutpoints, dtype=float))
            HbRrespdata.append(np.zeros(numoutpoints, dtype=float))
            HbRlfodata.append(np.zeros(numoutpoints, dtype=float))
            HbRcardsq.append(np.zeros(numoutpoints, dtype=float))
            HbRcardrms.append(np.zeros(numoutpoints, dtype=float))
            tHbcarddata.append(np.zeros(numoutpoints, dtype=float))
            tHbrespdata.append(np.zeros(numoutpoints, dtype=float))
            tHblfodata.append(np.zeros(numoutpoints, dtype=float))
            tHbcardsq.append(np.zeros(numoutpoints, dtype=float))
            tHbcardrms.append(np.zeros(numoutpoints, dtype=float))
            for thetimepoint in range(0, len(outtimeaxis)):
                # split out the lfo and cardiac components
                # print('doing ',thetimepoint)
                if thetimepoint > delaypoints:
                    spo2.rt_splitdata(
                        HbRrawdata[channum],
                        thetimepoint,
                        HbRcarddata[channum],
                        HbRcardsq[channum],
                        HbRcardrms[channum],
                        HbRrespdata[channum],
                        HbRlfodata[channum],
                        outsamplerate,
                    )
                    spo2.rt_splitdata(
                        HbOrawdata[channum],
                        thetimepoint,
                        HbOcarddata[channum],
                        HbOcardsq[channum],
                        HbOcardrms[channum],
                        HbOrespdata[channum],
                        HbOlfodata[channum],
                        outsamplerate,
                    )
                    spo2.rt_splitdata(
                        tHbrawdata[channum],
                        thetimepoint,
                        tHbcarddata[channum],
                        tHbcardsq[channum],
                        tHbcardrms[channum],
                        tHbrespdata[channum],
                        tHblfodata[channum],
                        outsamplerate,
                    )

        else:
            filtorder = 3
            theprefilter = spo2.noncausalprefilter()
            thewidecardfilter = cbvf.noncausalfilter()
            theprefilter.setbutter(usebutterworthfilter, filtorder)
            thewidecardfilter.settype("arb")
            thewidecardfilter.setarb(0.4, 0.5, 10.0, 12.0)
            deltafrac = 1.0 / 4.0
            thelowpassfilter = cbvf.noncausalfilter()
            thelowpassfilter.settype("arb")
            thelowpassfilter.setarb(0.0, 0.0, 0.25, 1.1 * 0.25)

            print("filtering cardiac")
            theprefilter.settype("cardiac")
            HbOcarddata.append(
                spo2.unpadvec(
                    theprefilter.apply(outsamplerate, spo2.padvec(HbOrawdata[channum]))
                )
            )
            HbRcarddata.append(
                spo2.unpadvec(
                    theprefilter.apply(outsamplerate, spo2.padvec(HbRrawdata[channum]))
                )
            )
            tHbcarddata.append(
                spo2.unpadvec(
                    theprefilter.apply(outsamplerate, spo2.padvec(tHbrawdata[channum]))
                )
            )
            print("smoothing cardrms")
            theprefilter.settype("cardsmooth")
            HbOcardrms.append(
                np.nan_to_num(
                    np.sqrt(
                        spo2.unpadvec(
                            theprefilter.apply(
                                outsamplerate,
                                spo2.padvec(np.square(HbOcarddata[channum])),
                            )
                        )
                    )
                )
            )
            HbRcardrms.append(
                np.nan_to_num(
                    np.sqrt(
                        spo2.unpadvec(
                            theprefilter.apply(
                                outsamplerate,
                                spo2.padvec(np.square(HbRcarddata[channum])),
                            )
                        )
                    )
                )
            )
            tHbcardrms.append(
                np.nan_to_num(
                    np.sqrt(
                        spo2.unpadvec(
                            theprefilter.apply(
                                outsamplerate,
                                spo2.padvec(np.square(tHbcarddata[channum])),
                            )
                        )
                    )
                )
            )  # NEW
            if np.mean(HbOcardrms[-1]) == 0.0:
                print(
                    "ERROR - there is no power in the cardiac band in channel",
                    outnames[channum],
                    "; data cannot be processed",
                )
                docardproc = False
                # sys.exit()
            print(
                "Channel",
                channum,
                "HbO cardrms min max:",
                np.min(HbOcardrms[channum]),
                np.max(HbOcardrms[channum]),
            )
            print(
                "Channel",
                channum,
                "HbR cardrms min max:",
                np.min(HbRcardrms[channum]),
                np.max(HbRcardrms[channum]),
            )
            if docardproc:
                thiscardmax, thiscardmin = spo2.peakdet(
                    HbOcarddata[-1],
                    rms(HbOcarddata[-1]) * deltafrac,
                    delta_x_fall=0.3,
                    delta_x_rise=0.1,
                    x=outtimeaxis,
                )
                cardmax.append(thiscardmax)
                cardmin.append(thiscardmin)
            print("filtering LFO")
            theprefilter.settype("lfo")
            HbOlfodata.append(
                spo2.unpadvec(
                    theprefilter.apply(outsamplerate, spo2.padvec(HbOrawdata[channum]))
                )
            )
            HbRlfodata.append(
                spo2.unpadvec(
                    theprefilter.apply(outsamplerate, spo2.padvec(HbRrawdata[channum]))
                )
            )
            tHblfodata.append(
                spo2.unpadvec(
                    theprefilter.apply(outsamplerate, spo2.padvec(tHbrawdata[channum]))
                )
            )
            print("filtering Resp")  # NEW
            theprefilter.settype("resp")  # NEW
            HbOrespdata.append(
                spo2.unpadvec(
                    theprefilter.apply(outsamplerate, spo2.padvec(HbOrawdata[channum]))
                )
            )  # NEW
            HbRrespdata.append(
                spo2.unpadvec(
                    theprefilter.apply(outsamplerate, spo2.padvec(HbRrawdata[channum]))
                )
            )  # NEW
            tHbrespdata.append(
                spo2.unpadvec(
                    theprefilter.apply(outsamplerate, spo2.padvec(tHbrawdata[channum]))
                )
            )  # NEW
            tHblowpass.append(
                spo2.unpadvec(
                    thelowpassfilter.apply(
                        outsamplerate, spo2.padvec(tHbrawdata[channum])
                    )
                )
            )

        # find peaks, calculate RR interval, etc.
        print("calling normalize cardiac")
        rangemed, envelope, envnormdata, valid = spo2.normalize_cardiac(
            HbOcarddata[channum], outsamplerate, env_upperpass=1.0
        )
        if docardproc:
            (
                tmppeaks,
                tmprrinterval,
                tmpinstbpm,
                tmpavgbpm,
                tmppeakheight,
                tmpconfidence,
                tmpwaveform,
                tmpfilteredpeaklist,
            ) = spo2.procpeaks(
                outtimeaxis,
                thewidecardfilter.apply(outsamplerate, HbOcarddata[channum]),
                cardmin[channum],
                cardmax[channum],
                outsamplerate,
                peakfilter=peakfilter,
            )
        tmpffthr = spo2.vechrfft(outsamplerate, HbOcarddata[channum])
        fftbpm.append(tmpffthr)
        peaks.append(tmppeaks)
        peakwaveform.append(tmpwaveform)
        cbvf.writevec(
            peakwaveform[-1],
            outputfilename + "_" + outnames[channum] + "_peakwaveform.txt",
        )
        rrinterval.append(tmprrinterval)
        instbpm.append(tmpinstbpm)
        avgbpm.append(tmpavgbpm)
        peakheight.append(tmppeakheight)
        confidence.append(tmpconfidence)
        instspo2.append(
            np.nan_to_num(
                100.0
                * HbOcardrms[channum]
                / np.nan_to_num((HbOcardrms[channum] + HbRcardrms[channum]))
            )
        )

    # define plot windows
    # thismanager = P.get_current_fig_manager()
    rawplot = []
    HbO_raw_ax = []
    HbR_raw_ax = []
    tHb_raw_ax = []
    HbO_card_ax = []
    HbR_card_ax = []
    tHb_card_ax = []
    HbO_lfo_ax = []
    HbR_lfo_ax = []
    tHb_lfo_ax = []
    HbO_card_line = []
    HbR_card_line = []
    tHb_card_line = []
    HbO_lfo_line = []
    HbR_lfo_line = []
    tHb_lfo_line = []
    HbO_raw_line = []
    HbR_raw_line = []
    tHb_raw_line = []
    for channum in range(0, len(thechans)):
        rawplot.append(P.figure(figsize=(16, 9)))
        rawplot[-1].set_size_inches(16.0, 9.0)
        rawplot[-1].suptitle(
            outputfilename + " " + outnames[channum], fontsize=18, fontweight="bold"
        )
        if raw_plot:
            HbO_raw_ax.append(rawplot[-1].add_subplot(3, 3, 1))
            HbR_raw_ax.append(rawplot[-1].add_subplot(3, 3, 4))
            tHb_raw_ax.append(rawplot[-1].add_subplot(3, 3, 7))
        if cardplot:
            HbO_card_ax.append(rawplot[-1].add_subplot(3, 3, 2))
            HbR_card_ax.append(rawplot[-1].add_subplot(3, 3, 5))
            tHb_card_ax.append(rawplot[-1].add_subplot(3, 3, 8))
        if lfoplot:
            HbO_lfo_ax.append(rawplot[-1].add_subplot(3, 3, 3))
            HbR_lfo_ax.append(rawplot[-1].add_subplot(3, 3, 6))
            tHb_lfo_ax.append(rawplot[-1].add_subplot(3, 3, 9))
        rawplot[-1].subplots_adjust(hspace=0.35)
        if cardplot:
            HbO_card_line.append(
                HbO_card_ax[-1].plot(outtimeaxis, HbOcarddata[channum], "b-")[0]
            )
            if docardproc:
                HbO_card_line.append(
                    HbO_card_ax[-1].scatter(
                        cardmin[channum][:, 0], cardmin[channum][:, 1], color="blue"
                    )
                )
            HbO_card_line[-1].axes.set_title("HbO cardiac data")
            HbR_card_line.append(
                HbR_card_ax[-1].plot(outtimeaxis, HbRcarddata[channum], "r-")[0]
            )
            HbR_card_line[-1].axes.set_title("HbR cardiac data")
            tHb_card_line.append(
                tHb_card_ax[-1].plot(outtimeaxis, tHbcarddata[channum], "g-")[0]
            )
            tHb_card_line[-1].axes.set_title("tHb cardiac data")
        if lfoplot:
            HbO_lfo_line.append(
                HbO_lfo_ax[-1].plot(outtimeaxis, HbOlfodata[channum], "b-")[0]
            )
            HbO_lfo_line[-1].axes.set_title("HbO LFO data")
            HbR_lfo_line.append(
                HbR_lfo_ax[-1].plot(outtimeaxis, HbRlfodata[channum], "r-")[0]
            )
            HbR_lfo_line[-1].axes.set_title("HbR LFO data")
            tHb_lfo_line.append(
                tHb_lfo_ax[-1].plot(outtimeaxis, tHblfodata[channum], "g-")[0]
            )
            tHb_lfo_line[-1].axes.set_title("tHb LFO data")
        if raw_plot:
            HbO_raw_line.append(
                HbO_raw_ax[-1].plot(outtimeaxis, HbOrawdata[channum], "b-")[0]
            )
            HbO_raw_line[-1].axes.set_title("HbO raw data")
            HbR_raw_line.append(
                HbR_raw_ax[-1].plot(outtimeaxis, HbRrawdata[channum], "r-")[0]
            )
            HbR_raw_line[-1].axes.set_title("HbR raw data")
            tHb_raw_line.append(
                tHb_raw_ax[-1].plot(outtimeaxis, tHbrawdata[channum], "g-")[0]
            )
            tHb_raw_line[-1].axes.set_title("tHb raw data")

    if dodisplay:
        for channum in range(0, len(thechans)):
            rawplot[channum].show()
            rawplot[channum].set_size_inches(16, 9)

    cols = []
    d = {}
    d["Time"] = outtimeaxis
    cols.append("Time")
    for channum in range(0, len(thechans)):
        d[outnames[channum] + "_IR"] = outirdata[channum]
        cols.append(outnames[channum] + "_IR")
        d[outnames[channum] + "_VS"] = outvisdata[channum]
        cols.append(outnames[channum] + "_VS")
        d[outnames[channum] + "_HbOraw"] = HbOrawdata[channum]
        cols.append(outnames[channum] + "_HbOraw")
        d[outnames[channum] + "_HbOlfo"] = HbOlfodata[channum]
        cols.append(outnames[channum] + "_HbOlfo")
        d[outnames[channum] + "_HbOcard"] = HbOcarddata[channum]
        cols.append(outnames[channum] + "_HbOcard")
        d[outnames[channum] + "_HbRraw"] = HbRrawdata[channum]
        cols.append(outnames[channum] + "_HbRraw")
        d[outnames[channum] + "_HbRlfo"] = HbRlfodata[channum]
        cols.append(outnames[channum] + "_HbRlfo")
        d[outnames[channum] + "_HbRcard"] = HbRcarddata[channum]
        cols.append(outnames[channum] + "_HbRcard")
        d[outnames[channum] + "_tHbraw"] = tHbrawdata[channum]
        cols.append(outnames[channum] + "_tHbraw")
        d[outnames[channum] + "_tHblfo"] = tHblfodata[channum]
        cols.append(outnames[channum] + "_tHblfo")
        d[outnames[channum] + "_tHbcard"] = tHbcarddata[channum]
        cols.append(outnames[channum] + "_tHbcard")
        d[outnames[channum] + "_tHbresp"] = tHbrespdata[channum]  # NEW
        cols.append(outnames[channum] + "_tHbresp")  # NEW
        d[outnames[channum] + "_HbOresp"] = HbOrespdata[channum]  # NEW
        cols.append(outnames[channum] + "_HbOresp")  # NEW
        d[outnames[channum] + "_HbRresp"] = HbRrespdata[channum]  # NEW
        cols.append(outnames[channum] + "_HbRresp")  # NEW
        d[outnames[channum] + "_tHbcardrms"] = tHbcardrms[channum]  # NEW
        cols.append(outnames[channum] + "_tHbcardrms")  # NEW
        d[outnames[channum] + "_HbOcardrms"] = HbOcardrms[channum]  # NEW
        cols.append(outnames[channum] + "_HbOcardrms")  # NEW
        d[outnames[channum] + "_HbRcardrms"] = HbRcardrms[channum]  # NEW
        cols.append(outnames[channum] + "_HbRcardrms")  # NEW
        d[outnames[channum] + "_tHblowpass"] = tHblowpass[channum]  # NEW
        cols.append(outnames[channum] + "_tHblowpass")  # NEW
        d[outnames[channum] + "_peaks"] = peaks[channum]
        cols.append(outnames[channum] + "_peaks")
        d[outnames[channum] + "_rri"] = rrinterval[channum]
        cols.append(outnames[channum] + "_rri")
        d[outnames[channum] + "_instbpm"] = instbpm[channum]
        cols.append(outnames[channum] + "_instbpm")
        d[outnames[channum] + "_peakheight"] = peakheight[channum]
        cols.append(outnames[channum] + "_peakheight")
        d[outnames[channum] + "_ratiospo2"] = ratiospo2[channum]
        cols.append(outnames[channum] + "_ratiospo2")
        d[outnames[channum] + "_instspo2"] = instspo2[channum]
        cols.append(outnames[channum] + "_instspo2")
        d[outnames[channum] + "_confidence"] = confidence[channum]
        cols.append(outnames[channum] + "_confidence")
        d[outnames[channum] + "_fftbpm"] = fftbpm[channum]
        cols.append(outnames[channum] + "_fftbpm")
        d[outnames[channum] + "_avgbpm"] = avgbpm[channum]
        cols.append(outnames[channum] + "_avgbpm")
    d["button"] = outbuttonmarkers
    cols.append("button")
    d["calibrate"] = outcalibmarkers
    cols.append("calibrate")
    if togglesexist:
        d["toggle"] = outtogglemarkers
        cols.append("toggle")
    if syncsexist:
        d["sync"] = outsyncmarkers
        cols.append("sync")
    if externalsexist:
        d["external"] = outexternalmarkers
        cols.append("external")
    df = pd.DataFrame(data=d)
    df = df[cols]
    df.to_csv(outputfilename + "_alldata.txt", sep="\t", index=False)

    # now write out the individual channels
    if writeindividual:
        for thecolumn in cols[1:]:
            df[thecolumn].to_csv(
                outputfilename + "_" + thecolumn + ".txt", sep="\t", index=False
            )

    # also write out the list of markers
    if len(buttonmarkerlist) > 0:
        cbvf.writevec(buttonmarkerlist, outputfilename + "_" + "buttontimes.txt")

    if dodisplay:
        P.show()


if __name__ == "__main__":
    main()
